diff --git a/pjsip/src/pjsip-ua/sip_reg.c b/pjsip/src/pjsip-ua/sip_reg.c
index d364e892f..c7bf59e1b 100644
--- a/pjsip/src/pjsip-ua/sip_reg.c
+++ b/pjsip/src/pjsip-ua/sip_reg.c
@@ -50,6 +50,9 @@
 static const pj_str_t XUID_PARAM_NAME = { "x-uid", 5 };
 
 
+#define TRACE_(expr) PJ_LOG(3,expr)
+
+
 /* Current/pending operation */
 enum regc_op
 {
@@ -170,11 +173,18 @@ PJ_DEF(pj_status_t) pjsip_regc_destroy(pjsip_regc *regc)
 {
     PJ_ASSERT_RETURN(regc, PJ_EINVAL);
 
+    TRACE_((regc->pool->obj_name,
+	    "Destroying, has_tsx=%d, busy_ctr=%d",
+	    regc->has_tsx, pj_atomic_get(regc->busy_ctr)));
+
     pj_lock_acquire(regc->lock);
     if (regc->has_tsx || pj_atomic_get(regc->busy_ctr) != 0) {
 	regc->_delete_flag = 1;
 	regc->cb = NULL;
 	pj_lock_release(regc->lock);
+	TRACE_((regc->pool->obj_name,
+		"Destroy pending, has_tsx=%d, busy_ctr=%d",
+		regc->has_tsx, pj_atomic_get(regc->busy_ctr)));
     } else {
 	pjsip_tpselector_dec_ref(&regc->tp_sel);
 	if (regc->last_transport) {
@@ -190,6 +200,8 @@ PJ_DEF(pj_status_t) pjsip_regc_destroy(pjsip_regc *regc)
 	pj_lock_destroy(regc->lock);
 	regc->lock = NULL;
 
+	TRACE_((regc->pool->obj_name, "Destroyed."));
+
 	pjsip_auth_clt_deinit(&regc->auth_sess);
 	pjsip_endpt_release_pool(regc->endpt, regc->pool);
     }
@@ -787,9 +799,13 @@ static void call_callback(pjsip_regc *regc, pj_status_t status, int st_code,
     if (!regc->cb)
 	return;
 
+    TRACE_((regc->pool->obj_name, "Invoking callback.."));
+
     cbparam_init(&cbparam, regc, status, st_code, reason, rdata, expiration,
                  contact_cnt, contact, is_unreg);
     (*regc->cb)(&cbparam);
+
+    TRACE_((regc->pool->obj_name, "Returned from callback"));
 }
 
 static void regc_refresh_timer_cb( pj_timer_heap_t *timer_heap,
@@ -1082,6 +1098,8 @@ static void regc_tsx_callback(void *token, pjsip_event *event)
     pj_bool_t handled = PJ_TRUE;
     pj_bool_t update_contact = PJ_FALSE;
 
+    TRACE_((regc->pool->obj_name, "Starting regc_tsx_callback().."));
+
     pjsip_regc_add_ref(regc);
     pj_lock_acquire(regc->lock);
 
@@ -1116,7 +1134,9 @@ static void regc_tsx_callback(void *token, pjsip_event *event)
 
         /* Call regc tsx callback before handling any response */
         pj_lock_release(regc->lock);
+	TRACE_((regc->pool->obj_name, "Invoking tsx_cb callback.."));
         (*regc->tsx_cb)(&param);
+	TRACE_((regc->pool->obj_name, "Returned from tsx_cb callback"));
         pj_lock_acquire(regc->lock);
 
         if (param.contact_cnt >= 0) {
@@ -1381,6 +1401,8 @@ handle_err:
 
     pj_lock_release(regc->lock);
 
+    TRACE_((regc->pool->obj_name, "Finished regc_tsx_callback().."));
+
     /* Delete the record if user destroy regc during the callback. */
     pjsip_regc_dec_ref(regc);
 }
@@ -1392,6 +1414,8 @@ PJ_DEF(pj_status_t) pjsip_regc_send(pjsip_regc *regc, pjsip_tx_data *tdata)
     pjsip_expires_hdr *expires_hdr;
     pj_uint32_t cseq;
 
+    TRACE_((regc->pool->obj_name, "Starting pjsip_regc_send().."));
+
     pjsip_regc_add_ref(regc);
     pj_lock_acquire(regc->lock);
 
@@ -1402,6 +1426,9 @@ PJ_DEF(pj_status_t) pjsip_regc_send(pjsip_regc *regc, pjsip_tx_data *tdata)
 	pjsip_tx_data_dec_ref( tdata );
 	pj_lock_release(regc->lock);
 	pj_atomic_dec(regc->busy_ctr);
+
+	TRACE_((regc->pool->obj_name, "Failed pjsip_regc_send(), busy."));
+
 	return PJSIP_EBUSY;
     }
 
@@ -1467,6 +1494,8 @@ PJ_DEF(pj_status_t) pjsip_regc_send(pjsip_regc *regc, pjsip_tx_data *tdata)
 	regc->has_tsx = PJ_FALSE;
 
 	PJ_PERROR(4,(THIS_FILE, status, "Error sending request"));
+	TRACE_((regc->pool->obj_name, "pjsip_endpt_send_request() failed: %d",
+		status));
     }
 
     /* Reacquire the lock */
@@ -1492,6 +1521,8 @@ PJ_DEF(pj_status_t) pjsip_regc_send(pjsip_regc *regc, pjsip_tx_data *tdata)
 
     pj_lock_release(regc->lock);
 
+    TRACE_((regc->pool->obj_name, "Finished pjsip_regc_send().."));
+
     /* Delete the record if user destroy regc during the callback. */
     pjsip_regc_dec_ref(regc);
 
